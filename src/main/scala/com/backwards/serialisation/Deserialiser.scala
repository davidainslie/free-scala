package com.backwards.serialisation

import scala.util.Using
import cats.Semigroup
import cats.implicits._
import io.circe.parser._
import io.circe.{Json, ParsingFailure}
import com.backwards.json.Jsonl

trait Deserialiser[A] {
  def deserialise(bytes: Array[Byte]): DeserialiserError Either A
}

object Deserialiser {
  implicit val deserialiserUnit: Deserialiser[Unit] =
    (_: Array[Byte]) => ().asRight

  implicit val deserialiserBytes: Deserialiser[Array[Byte]] =
    _.asRight

  implicit val deserialiserString: Deserialiser[String] =
    (bytes: Array[Byte]) => new String(bytes).asRight

  implicit val deserialiserJson: Deserialiser[Json] =
    (bytes: Array[Byte]) => parse(new String(bytes)).leftMap(e => DeserialiserError(e.message, e.underlying.some))

  implicit val deserialiserJsonl: Deserialiser[Jsonl] =
    (bytes: Array[Byte]) => Using(scala.io.Source.fromBytes(bytes))(
      _.getLines()
        .map(parse)
        .toVector
        .traverse(_.toValidatedNel)
        .toEither
        .leftMap(_.map(DeserialiserError.apply).reduce)
        .map(Jsonl.apply)
    ).toEither.valueOr(t => DeserialiserError(t.getMessage, t.getCause.some).asLeft)
}

final case class DeserialiserError(message: String, cause: Option[Throwable] = None)
  extends Exception(message, cause.fold(null.asInstanceOf[Throwable])(identity))

object DeserialiserError {
  def apply(parsingFailure: ParsingFailure): DeserialiserError =
    DeserialiserError(parsingFailure.message, parsingFailure.underlying.some)

  /**
   * Unfortunately we do not accumulate the cause of multiple errors
   */
  implicit val semigroupDeserialiserError: Semigroup[DeserialiserError] =
    (x: DeserialiserError, y: DeserialiserError) => DeserialiserError(List(x.message, y.message).mkString("; "), x.cause orElse y.cause)
}